(function(){"use strict";function k(i,t,e=0,n=i.length-1,o=F){for(;n>e;){if(n-e>600){const c=n-e+1,l=t-e+1,h=Math.log(c),u=.5*Math.exp(2*h/3),m=.5*Math.sqrt(h*u*(c-u)/c)*(l-c/2<0?-1:1),p=Math.max(e,Math.floor(t-l*u/c+m)),d=Math.min(n,Math.floor(t+(c-l)*u/c+m));k(i,t,p,d,o)}const s=i[t];let a=e,r=n;for(B(i,e,t),o(i[n],s)>0&&B(i,e,n);a<r;){for(B(i,a,r),a++,r--;o(i[a],s)<0;)a++;for(;o(i[r],s)>0;)r--}o(i[e],s)===0?B(i,e,r):(r++,B(i,r,n)),r<=t&&(e=r+1),t<=r&&(n=r-1)}}function B(i,t,e){const n=i[t];i[t]=i[e],i[e]=n}function F(i,t){return i<t?-1:i>t?1:0}class P{constructor(t=9){this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(this._maxEntries*.4)),this.clear()}all(){return this._all(this.data,[])}search(t){let e=this.data;const n=[];if(!S(t,e))return n;const o=this.toBBox,s=[];for(;e;){for(let a=0;a<e.children.length;a++){const r=e.children[a],c=e.leaf?o(r):r;S(t,c)&&(e.leaf?n.push(r):R(t,c)?this._all(r,n):s.push(r))}e=s.pop()}return n}collides(t){let e=this.data;if(!S(t,e))return!1;const n=[];for(;e;){for(let o=0;o<e.children.length;o++){const s=e.children[o],a=e.leaf?this.toBBox(s):s;if(S(t,a)){if(e.leaf||R(t,a))return!0;n.push(s)}}e=n.pop()}return!1}load(t){if(!(t&&t.length))return this;if(t.length<this._minEntries){for(let n=0;n<t.length;n++)this.insert(t[n]);return this}let e=this._build(t.slice(),0,t.length-1,0);if(!this.data.children.length)this.data=e;else if(this.data.height===e.height)this._splitRoot(this.data,e);else{if(this.data.height<e.height){const n=this.data;this.data=e,e=n}this._insert(e,this.data.height-e.height-1,!0)}return this}insert(t){return t&&this._insert(t,this.data.height-1),this}clear(){return this.data=M([]),this}remove(t,e){if(!t)return this;let n=this.data;const o=this.toBBox(t),s=[],a=[];let r,c,l;for(;n||s.length;){if(n||(n=s.pop(),c=s[s.length-1],r=a.pop(),l=!0),n.leaf){const h=D(t,n.children,e);if(h!==-1)return n.children.splice(h,1),s.push(n),this._condense(s),this}!l&&!n.leaf&&R(n,o)?(s.push(n),a.push(r),r=0,c=n,n=n.children[0]):c?(r++,n=c.children[r],l=!1):n=null}return this}toBBox(t){return t}compareMinX(t,e){return t.minX-e.minX}compareMinY(t,e){return t.minY-e.minY}toJSON(){return this.data}fromJSON(t){return this.data=t,this}_all(t,e){const n=[];for(;t;)t.leaf?e.push(...t.children):n.push(...t.children),t=n.pop();return e}_build(t,e,n,o){const s=n-e+1;let a=this._maxEntries,r;if(s<=a)return r=M(t.slice(e,n+1)),g(r,this.toBBox),r;o||(o=Math.ceil(Math.log(s)/Math.log(a)),a=Math.ceil(s/Math.pow(a,o-1))),r=M([]),r.leaf=!1,r.height=o;const c=Math.ceil(s/a),l=c*Math.ceil(Math.sqrt(a));C(t,e,n,l,this.compareMinX);for(let h=e;h<=n;h+=l){const u=Math.min(h+l-1,n);C(t,h,u,c,this.compareMinY);for(let m=h;m<=u;m+=c){const p=Math.min(m+c-1,u);r.children.push(this._build(t,m,p,o-1))}}return g(r,this.toBBox),r}_chooseSubtree(t,e,n,o){for(;o.push(e),!(e.leaf||o.length-1===n);){let s=1/0,a=1/0,r;for(let c=0;c<e.children.length;c++){const l=e.children[c],h=I(l),u=W(t,l)-h;u<a?(a=u,s=h<s?h:s,r=l):u===a&&h<s&&(s=h,r=l)}e=r||e.children[0]}return e}_insert(t,e,n){const o=n?t:this.toBBox(t),s=[],a=this._chooseSubtree(o,this.data,e,s);for(a.children.push(t),y(a,o);e>=0&&s[e].children.length>this._maxEntries;)this._split(s,e),e--;this._adjustParentBBoxes(o,s,e)}_split(t,e){const n=t[e],o=n.children.length,s=this._minEntries;this._chooseSplitAxis(n,s,o);const a=this._chooseSplitIndex(n,s,o),r=M(n.children.splice(a,n.children.length-a));r.height=n.height,r.leaf=n.leaf,g(n,this.toBBox),g(r,this.toBBox),e?t[e-1].children.push(r):this._splitRoot(n,r)}_splitRoot(t,e){this.data=M([t,e]),this.data.height=t.height+1,this.data.leaf=!1,g(this.data,this.toBBox)}_chooseSplitIndex(t,e,n){let o,s=1/0,a=1/0;for(let r=e;r<=n-e;r++){const c=_(t,0,r,this.toBBox),l=_(t,r,n,this.toBBox),h=J(c,l),u=I(c)+I(l);h<s?(s=h,o=r,a=u<a?u:a):h===s&&u<a&&(a=u,o=r)}return o||n-e}_chooseSplitAxis(t,e,n){const o=t.leaf?this.compareMinX:N,s=t.leaf?this.compareMinY:$,a=this._allDistMargin(t,e,n,o),r=this._allDistMargin(t,e,n,s);a<r&&t.children.sort(o)}_allDistMargin(t,e,n,o){t.children.sort(o);const s=this.toBBox,a=_(t,0,e,s),r=_(t,n-e,n,s);let c=Y(a)+Y(r);for(let l=e;l<n-e;l++){const h=t.children[l];y(a,t.leaf?s(h):h),c+=Y(a)}for(let l=n-e-1;l>=e;l--){const h=t.children[l];y(r,t.leaf?s(h):h),c+=Y(r)}return c}_adjustParentBBoxes(t,e,n){for(let o=n;o>=0;o--)y(e[o],t)}_condense(t){for(let e=t.length-1,n;e>=0;e--)t[e].children.length===0?e>0?(n=t[e-1].children,n.splice(n.indexOf(t[e]),1)):this.clear():g(t[e],this.toBBox)}}function D(i,t,e){if(!e)return t.indexOf(i);for(let n=0;n<t.length;n++)if(e(i,t[n]))return n;return-1}function g(i,t){_(i,0,i.children.length,t,i)}function _(i,t,e,n,o){o||(o=M(null)),o.minX=1/0,o.minY=1/0,o.maxX=-1/0,o.maxY=-1/0;for(let s=t;s<e;s++){const a=i.children[s];y(o,i.leaf?n(a):a)}return o}function y(i,t){return i.minX=Math.min(i.minX,t.minX),i.minY=Math.min(i.minY,t.minY),i.maxX=Math.max(i.maxX,t.maxX),i.maxY=Math.max(i.maxY,t.maxY),i}function N(i,t){return i.minX-t.minX}function $(i,t){return i.minY-t.minY}function I(i){return(i.maxX-i.minX)*(i.maxY-i.minY)}function Y(i){return i.maxX-i.minX+(i.maxY-i.minY)}function W(i,t){return(Math.max(t.maxX,i.maxX)-Math.min(t.minX,i.minX))*(Math.max(t.maxY,i.maxY)-Math.min(t.minY,i.minY))}function J(i,t){const e=Math.max(i.minX,t.minX),n=Math.max(i.minY,t.minY),o=Math.min(i.maxX,t.maxX),s=Math.min(i.maxY,t.maxY);return Math.max(0,o-e)*Math.max(0,s-n)}function R(i,t){return i.minX<=t.minX&&i.minY<=t.minY&&t.maxX<=i.maxX&&t.maxY<=i.maxY}function S(i,t){return t.minX<=i.maxX&&t.minY<=i.maxY&&t.maxX>=i.minX&&t.maxY>=i.minY}function M(i){return{children:i,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function C(i,t,e,n,o){const s=[t,e];for(;s.length;){if(e=s.pop(),t=s.pop(),e-t<=n)continue;const a=t+Math.ceil((e-t)/n/2)*n;k(i,a,t,e,o),s.push(t,a,a,e)}}let w=null;function b(i,t){if(!i)return 0;const e=i[t];return typeof e=="number"&&isFinite(e)?e:0}let z={};function G(i,t=8){const e=[...i].filter(s=>s>0).sort((s,a)=>s-a);if(e.length===0)return[];const n=Math.ceil(e.length/t),o=[];for(let s=1;s<t;s++)o.push(e[s*n]??e[e.length-1]);return console.log("[Worker] Computed thresholds:",o),o}self.onmessage=async i=>{const{id:t,type:e,data:n}=i.data;console.log(`[Worker] Received message: ${e}`,{id:t,data:n}),w&&(w.abort(),console.log("[Worker] Aborted previous operation")),w=new AbortController;const o=w.signal;try{switch(e){case"LOAD_AND_PROCESS_DATA":{const{url:s,selectedMetric:a}=n;console.log(`[Worker] Loading data from: ${s}, metric: ${a}`),self.postMessage({type:"PROGRESS",data:{phase:"Fetching market data..."}});const r=await fetch(s,{signal:o});if(!r.ok)throw new Error(`Fetch failed: ${r.status}`);console.log(`[Worker] Fetch successful, status: ${r.status}`);const c=await r.arrayBuffer();console.log(`[Worker] Received buffer size: ${c.byteLength} bytes`);let l;try{const f=new TextDecoder().decode(c);l=JSON.parse(f),console.log("[Worker] JSON parsed successfully")}catch(f){throw console.error("[Worker] JSON parse failed:",f),new Error("Failed to parse JSON: "+f.message)}const{last_updated_utc:h,zip_codes:u}=l;if(!u)throw new Error("Missing zip_codes data");console.log(`[Worker] Found ${Object.keys(u).length} ZIP codes, last updated: ${h}`),self.postMessage({type:"PROGRESS",data:{phase:"Indexing ZIP codes..."}});const m={},p=[],d=Object.entries(u);for(let f=0;f<d.length;f++){if(o.aborted)return;const[x,X]=d[f];X.zipCode=x,m[x]=X;const O=b(X,a);O>0&&p.push(O),f%2e3===0&&self.postMessage({type:"PROGRESS",data:{phase:"Indexing ZIP codes...",processed:f,total:d.length}})}const E={min:Math.min(...p),max:Math.max(...p)};console.log(`[Worker] Data processed: ${Object.keys(m).length} ZIPs, bounds:`,E),self.postMessage({type:"DATA_PROCESSED",id:t,data:{zip_codes:m,last_updated_utc:h,bounds:E}});break}case"PROCESS_GEOJSON":{const{geojson:s,zipData:a,selectedMetric:r,viewport:c}=n;if(!s?.features)throw new Error("Invalid GeoJSON");console.log(`[Worker] Processing GeoJSON: ${s.features.length} features, metric: ${r}`),self.postMessage({type:"PROGRESS",data:{phase:"Building spatial index..."}});const l=new P,h=[];for(let f of s.features){if(o.aborted)return;const x=f.properties?.ZCTA5CE20;if(!x||!a[x])continue;const[X,O,j,Z]=T(f);l.insert({minX:X,minY:O,maxX:j,maxY:Z,feature:f}),z[x]=f,h.push(f)}self.postMessage({type:"PROGRESS",data:{phase:"Filtering viewport..."}});const u=c?l.search(c).map(f=>f.feature):h,m=u.map(f=>b(a[f.properties.ZCTA5CE20],r)),p=G(m,8),d=u.map(f=>({...f,properties:{...f.properties,metricValue:b(a[f.properties.ZCTA5CE20],r)}})),E=["step",["get","metricValue"],A(0),...p.flatMap((f,x)=>[f,A(x+1)])];console.log(`[Worker] GeoJSON processed: ${d.length} visible features, ${p.length} buckets, color steps applied`),self.postMessage({type:"GEOJSON_PROCESSED",id:t,data:{type:"FeatureCollection",features:d,bucketExpression:E}});break}default:throw new Error(`Unknown type: ${e}`)}}catch(s){o.aborted||(console.error("[Worker] Error:",s),self.postMessage({type:"ERROR",id:t,error:s instanceof Error?s.message:"Unknown error"}))}};function T(i){if(i.geometry.type==="Polygon"){const t=i.geometry.coordinates.flat(2),e=t.filter((o,s)=>s%2===0),n=t.filter((o,s)=>s%2!==0);return[Math.min(...e),Math.min(...n),Math.max(...e),Math.max(...n)]}else if(i.geometry.type==="MultiPolygon"){const t=i.geometry.coordinates.flat(3),e=t.filter((o,s)=>s%2===0),n=t.filter((o,s)=>s%2!==0);return[Math.min(...e),Math.min(...n),Math.max(...e),Math.max(...n)]}return[0,0,0,0]}function A(i){const t=["#FFF9B0","#FFEB84","#FFD166","#FF9A56","#E84C61","#C13584","#7B2E8D","#2E0B59"];return t[Math.min(i,t.length-1)]}})();
