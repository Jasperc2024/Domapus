(function(){"use strict";let b=null;function m(l,r){if(!l)return 0;const o=l[r];return typeof o=="number"&&isFinite(o)?o:0}let C={};function R(l,r=8){const o=[...l].filter(t=>t>0).sort((t,n)=>t-n);if(o.length===0)return[];const d=o[0],f=o[o.length-1];if(d===f)return[d];const e=[],i=(f-d)*1e-6||1e-6,u=t=>{const n=Math.floor(t*(o.length-1));return o[n]};for(let t=1;t<r;t++){let n=u(t/r);e.length&&n<=e[e.length-1]&&(n=e[e.length-1]+i),e.push(n)}return console.log("[Worker] Computed thresholds:",e),e}self.onmessage=async l=>{const{id:r,type:o,data:d}=l.data;console.log(`[Worker] Received message: ${o}`,{id:r,data:d}),b&&(b.abort(),console.log("[Worker] Aborted previous operation")),b=new AbortController;const f=b.signal;try{switch(o){case"LOAD_AND_PROCESS_DATA":{let e=function(a){const h=[...a].filter(p=>p>0).sort((p,y)=>p-y);if(h.length===0)return{min:0,max:1};const E=p=>{const y=Math.floor(p*(h.length-1));return h[y]};return{min:E(.05),max:E(.95)}};const{url:i,selectedMetric:u}=d;console.log(`[Worker] Loading data from: ${i}, metric: ${u}`),self.postMessage({type:"PROGRESS",data:{phase:"Fetching market data..."}});const t=await fetch(i,{signal:f});if(!t.ok)throw new Error(`Fetch failed: ${t.status}`);console.log(`[Worker] Fetch successful, status: ${t.status}`);const n=await t.arrayBuffer();console.log(`[Worker] Received buffer size: ${n.byteLength} bytes`);let k;try{const a=new TextDecoder().decode(n);k=JSON.parse(a),console.log("[Worker] JSON parsed successfully")}catch(a){throw console.error("[Worker] JSON parse failed:",a),new Error("Failed to parse JSON: "+a.message)}const{last_updated_utc:O,zip_codes:g}=k;if(!g)throw new Error("Missing zip_codes data");console.log(`[Worker] Found ${Object.keys(g).length} ZIP codes, last updated: ${O}`),self.postMessage({type:"PROGRESS",data:{phase:"Indexing ZIP codes..."}});const S={},s=[],c=Object.entries(g);for(let a=0;a<c.length;a++){if(f.aborted)return;const[h,E]=c[a];E.zipCode=h,S[h]=E;const p=m(E,u);p>0&&s.push(p),a%2e3===0&&self.postMessage({type:"PROGRESS",data:{phase:"Indexing ZIP codes...",processed:a,total:c.length}})}const F=e(s);console.log(`[Worker] Data processed: ${Object.keys(S).length} ZIPs, bounds:`,F),self.postMessage({type:"DATA_PROCESSED",id:r,data:{zip_codes:S,last_updated_utc:O,bounds:F}});break}case"PROCESS_GEOJSON":{const{geojson:e,zipData:i,selectedMetric:u}=d;if(!e?.features)throw new Error("Invalid GeoJSON");console.log(`[Worker] Processing GeoJSON: ${e.features.length} features, metric: ${u}`),self.postMessage({type:"PROGRESS",data:{phase:"Processing features..."}});const t=[];for(let s of e.features){if(f.aborted)return;const c=s.properties?.ZCTA5CE20;!c||!i[c]||(C[c]=s,t.push(s))}const n=t,k=Object.values(i).map(s=>m(s,u)),O=R(k),g=n.map(s=>({...s,properties:{...s.properties,metricValue:m(i[s.properties.ZCTA5CE20],u)}})),S=["step",["get","metricValue"],w(0),...O.flatMap((s,c)=>[s,w(c+1)])];console.log(`[Worker] GeoJSON processed: ${g.length} features, ${O.length} buckets, color steps applied`),self.postMessage({type:"GEOJSON_PROCESSED",id:r,data:{type:"FeatureCollection",features:g,bucketExpression:S}});break}default:throw new Error(`Unknown type: ${o}`)}}catch(e){f.aborted||(console.error("[Worker] Error:",e),self.postMessage({type:"ERROR",id:r,error:e instanceof Error?e.message:"Unknown error"}))}};function w(l){const r=["#FFF9B0","#FFEB84","#FFD166","#FF9A56","#E84C61","#C13584","#7B2E8D","#2E0B59"];return r[Math.min(l,r.length-1)]}})();
